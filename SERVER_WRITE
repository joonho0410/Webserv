/* copying response */
                if ((kqueue_data*)curr_event->udata != 0)
                {
                    if (((kqueue_data*)(curr_event->udata))->is_cgi == true)
                    {
                        int pid = fork();
                        if (pid == 0)
                        {
                            close(((kqueue_data*)(curr_event->udata))->fd[0]);
                            dup2(((kqueue_data*)(curr_event->udata))->fd[1], 1);
                            char *argv[] = {"sh", "test.sh", "\0"};
                            execve("/bin/sh", argv, 0);
                        }
                    }
                    else
                    {
                        _m_clients[curr_event->ident].append(((kqueue_data*)(curr_event->udata))->response);
                        delete curr_event->udata;
                    }
                }

                /* send data to client */
                std::map<int, std::string>::iterator it = _m_clients.find(curr_event->ident);
                if (it != _m_clients.end())
                {
                    if (_m_clients[curr_event->ident] != "")
                    {
                        int n;
                        std::cout << "send data to " << curr_event->ident << ": " << _m_clients[curr_event->ident].c_str() << std::endl;
                        if ((n = write(curr_event->ident, _m_clients[curr_event->ident].c_str(),
                                        _m_clients[curr_event->ident].size()) == -1))
                        {
                            std::cerr << "client write error!" << std::endl;
                            _M_disconnect_client(curr_event->ident, _m_clients);  
                        }
                        else
                            _m_clients[curr_event->ident].clear();
                        _M_change_events(_m_change_list, curr_event->ident, EVFILT_READ, EV_ADD | EV_ONESHOT, 0, 0, NULL);
                    }
                }