 std::cout << "========== find location block =========== " << std::endl;
    size_t pos = 0;
    std::string str;
    std::string temp;
    struct server_config_struct ret;
    bool        valid = false;

    // if location block is empty return valid=false block; 
    if (server_block.location_block.empty()) {
        struct server_config_struct temp = {false};
        return temp;
    }

    int result;
    size_t max = 0;
    std::map <std::string, struct server_config_struct>::iterator begin = server_block.location_block.begin();
    std::map <std::string, struct server_config_struct>::iterator end = server_block.location_block.end();

    for (; begin != end; ++begin){
        size_t locaLen = begin->first.length();
        size_t urlLen = url.length();

        if (locaLen < urlLen){
            result = begin->first.compare(0, locaLen, url, 0, locaLen);
            if (result == 0){
                if (max < locaLen){
                    valid = true;
                    max = locaLen;
                    temp = url.substr(locaLen);
                    ret = begin->second;
                }
            }
        } else {
            result = begin->first.compare(0, urlLen, url, 0, urlLen);
            if (result == 0){
                if (max < urlLen){
                    valid = true;
                    max = urlLen;
                    temp = url.substr(urlLen);
                    ret = begin->second;
                }
            }
        }
    }
    
    if (valid == false){
        struct server_config_struct temp = {false};
        return temp;
    } else if (!ret.location_block.empty()){
        struct server_config_struct tempRet;
        std::string temp2 = temp;

        tempRet = _M_findLocationBlock(ret, temp2);
        if (tempRet.valid != false){
            url = temp2;
            return (tempRet);
        }
    }

    url = temp;
    return (ret);
